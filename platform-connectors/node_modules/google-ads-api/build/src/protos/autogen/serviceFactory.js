"use strict";
/* Autogenerated File! Do Not Edit */
Object.defineProperty(exports, "__esModule", { value: true });
const service_1 = require("../../service");
const index_1 = require("../index");
class ServiceFactory extends service_1.Service {
    constructor(clientOptions, customerOptions, hooks) {
        super(clientOptions, customerOptions, hooks !== null && hooks !== void 0 ? hooks : {});
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/AccountBudgetProposalService
     */
    get accountBudgetProposals() {
        const service = this.loadService("AccountBudgetProposalServiceClient");
        return {
            /**
             * @description create resources of type resources.IAccountBudgetProposal
             * @returns services.MutateAccountBudgetProposalResponse
             */
            create: async (accountBudgetProposals, options) => {
                const ops = this.buildOperations("create", accountBudgetProposals);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AccountBudgetProposalService.mutateAccountBudgetProposal",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAccountBudgetProposal(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateAccountBudgetProposalResponse
             */
            remove: async (accountBudgetProposals, options) => {
                const ops = this.buildOperations("remove", accountBudgetProposals);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AccountBudgetProposalService.mutateAccountBudgetProposal",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAccountBudgetProposal(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/AccountLinkService
     */
    get accountLinks() {
        const service = this.loadService("AccountLinkServiceClient");
        return {
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v14/AccountLinkService#createaccountlink
             */
            createAccountLink: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AccountLinkService.CreateAccountLink",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.createAccountLink(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.IAccountLink
             * @returns services.MutateAccountLinkResponse
             */
            update: async (accountLinks, options) => {
                const ops = this.buildOperations("update", accountLinks, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.AccountLink);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AccountLinkService.mutateAccountLink",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAccountLink(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateAccountLinkResponse
             */
            remove: async (accountLinks, options) => {
                const ops = this.buildOperations("remove", accountLinks);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AccountLinkService.mutateAccountLink",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAccountLink(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/AdGroupAdLabelService
     */
    get adGroupAdLabels() {
        const service = this.loadService("AdGroupAdLabelServiceClient");
        return {
            /**
             * @description create resources of type resources.IAdGroupAdLabel
             * @returns services.MutateAdGroupAdLabelsResponse
             */
            create: async (adGroupAdLabels, options) => {
                const ops = this.buildOperations("create", adGroupAdLabels);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AdGroupAdLabelService.mutateAdGroupAdLabels",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAdGroupAdLabels(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateAdGroupAdLabelsResponse
             */
            remove: async (adGroupAdLabels, options) => {
                const ops = this.buildOperations("remove", adGroupAdLabels);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AdGroupAdLabelService.mutateAdGroupAdLabels",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAdGroupAdLabels(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/AdGroupAdService
     */
    get adGroupAds() {
        const service = this.loadService("AdGroupAdServiceClient");
        return {
            /**
             * @description create resources of type resources.IAdGroupAd
             * @returns services.MutateAdGroupAdsResponse
             */
            create: async (adGroupAds, options) => {
                const ops = this.buildOperations("create", adGroupAds);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AdGroupAdService.mutateAdGroupAds",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAdGroupAds(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.IAdGroupAd
             * @returns services.MutateAdGroupAdsResponse
             */
            update: async (adGroupAds, options) => {
                const ops = this.buildOperations("update", adGroupAds, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.AdGroupAd);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AdGroupAdService.mutateAdGroupAds",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAdGroupAds(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateAdGroupAdsResponse
             */
            remove: async (adGroupAds, options) => {
                const ops = this.buildOperations("remove", adGroupAds);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AdGroupAdService.mutateAdGroupAds",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAdGroupAds(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/AdGroupAssetService
     */
    get adGroupAssets() {
        const service = this.loadService("AdGroupAssetServiceClient");
        return {
            /**
             * @description create resources of type resources.IAdGroupAsset
             * @returns services.MutateAdGroupAssetsResponse
             */
            create: async (adGroupAssets, options) => {
                const ops = this.buildOperations("create", adGroupAssets);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AdGroupAssetService.mutateAdGroupAssets",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAdGroupAssets(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.IAdGroupAsset
             * @returns services.MutateAdGroupAssetsResponse
             */
            update: async (adGroupAssets, options) => {
                const ops = this.buildOperations("update", adGroupAssets, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.AdGroupAsset);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AdGroupAssetService.mutateAdGroupAssets",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAdGroupAssets(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateAdGroupAssetsResponse
             */
            remove: async (adGroupAssets, options) => {
                const ops = this.buildOperations("remove", adGroupAssets);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AdGroupAssetService.mutateAdGroupAssets",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAdGroupAssets(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/AdGroupAssetSetService
     */
    get adGroupAssetSets() {
        const service = this.loadService("AdGroupAssetSetServiceClient");
        return {
            /**
             * @description create resources of type resources.IAdGroupAssetSet
             * @returns services.MutateAdGroupAssetSetsResponse
             */
            create: async (adGroupAssetSets, options) => {
                const ops = this.buildOperations("create", adGroupAssetSets);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AdGroupAssetSetService.mutateAdGroupAssetSets",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAdGroupAssetSets(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateAdGroupAssetSetsResponse
             */
            remove: async (adGroupAssetSets, options) => {
                const ops = this.buildOperations("remove", adGroupAssetSets);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AdGroupAssetSetService.mutateAdGroupAssetSets",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAdGroupAssetSets(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/AdGroupBidModifierService
     */
    get adGroupBidModifiers() {
        const service = this.loadService("AdGroupBidModifierServiceClient");
        return {
            /**
             * @description create resources of type resources.IAdGroupBidModifier
             * @returns services.MutateAdGroupBidModifiersResponse
             */
            create: async (adGroupBidModifiers, options) => {
                const ops = this.buildOperations("create", adGroupBidModifiers);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AdGroupBidModifierService.mutateAdGroupBidModifiers",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAdGroupBidModifiers(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.IAdGroupBidModifier
             * @returns services.MutateAdGroupBidModifiersResponse
             */
            update: async (adGroupBidModifiers, options) => {
                const ops = this.buildOperations("update", adGroupBidModifiers, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.AdGroupBidModifier);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AdGroupBidModifierService.mutateAdGroupBidModifiers",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAdGroupBidModifiers(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateAdGroupBidModifiersResponse
             */
            remove: async (adGroupBidModifiers, options) => {
                const ops = this.buildOperations("remove", adGroupBidModifiers);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AdGroupBidModifierService.mutateAdGroupBidModifiers",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAdGroupBidModifiers(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/AdGroupCriterionCustomizerService
     */
    get adGroupCriterionCustomizers() {
        const service = this.loadService("AdGroupCriterionCustomizerServiceClient");
        return {
            /**
             * @description create resources of type resources.IAdGroupCriterionCustomizer
             * @returns services.MutateAdGroupCriterionCustomizersResponse
             */
            create: async (adGroupCriterionCustomizers, options) => {
                const ops = this.buildOperations("create", adGroupCriterionCustomizers);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AdGroupCriterionCustomizerService.mutateAdGroupCriterionCustomizers",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAdGroupCriterionCustomizers(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateAdGroupCriterionCustomizersResponse
             */
            remove: async (adGroupCriterionCustomizers, options) => {
                const ops = this.buildOperations("remove", adGroupCriterionCustomizers);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AdGroupCriterionCustomizerService.mutateAdGroupCriterionCustomizers",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAdGroupCriterionCustomizers(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/AdGroupCriterionLabelService
     */
    get adGroupCriterionLabels() {
        const service = this.loadService("AdGroupCriterionLabelServiceClient");
        return {
            /**
             * @description create resources of type resources.IAdGroupCriterionLabel
             * @returns services.MutateAdGroupCriterionLabelsResponse
             */
            create: async (adGroupCriterionLabels, options) => {
                const ops = this.buildOperations("create", adGroupCriterionLabels);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AdGroupCriterionLabelService.mutateAdGroupCriterionLabels",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAdGroupCriterionLabels(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateAdGroupCriterionLabelsResponse
             */
            remove: async (adGroupCriterionLabels, options) => {
                const ops = this.buildOperations("remove", adGroupCriterionLabels);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AdGroupCriterionLabelService.mutateAdGroupCriterionLabels",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAdGroupCriterionLabels(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/AdGroupCriterionService
     */
    get adGroupCriteria() {
        const service = this.loadService("AdGroupCriterionServiceClient");
        return {
            /**
             * @description create resources of type resources.IAdGroupCriterion
             * @returns services.MutateAdGroupCriteriaResponse
             */
            create: async (adGroupCriteria, options) => {
                const ops = this.buildOperations("create", adGroupCriteria);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AdGroupCriterionService.mutateAdGroupCriteria",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAdGroupCriteria(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.IAdGroupCriterion
             * @returns services.MutateAdGroupCriteriaResponse
             */
            update: async (adGroupCriteria, options) => {
                const ops = this.buildOperations("update", adGroupCriteria, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.AdGroupCriterion);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AdGroupCriterionService.mutateAdGroupCriteria",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAdGroupCriteria(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateAdGroupCriteriaResponse
             */
            remove: async (adGroupCriteria, options) => {
                const ops = this.buildOperations("remove", adGroupCriteria);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AdGroupCriterionService.mutateAdGroupCriteria",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAdGroupCriteria(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/AdGroupCustomizerService
     */
    get adGroupCustomizers() {
        const service = this.loadService("AdGroupCustomizerServiceClient");
        return {
            /**
             * @description create resources of type resources.IAdGroupCustomizer
             * @returns services.MutateAdGroupCustomizersResponse
             */
            create: async (adGroupCustomizers, options) => {
                const ops = this.buildOperations("create", adGroupCustomizers);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AdGroupCustomizerService.mutateAdGroupCustomizers",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAdGroupCustomizers(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateAdGroupCustomizersResponse
             */
            remove: async (adGroupCustomizers, options) => {
                const ops = this.buildOperations("remove", adGroupCustomizers);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AdGroupCustomizerService.mutateAdGroupCustomizers",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAdGroupCustomizers(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/AdGroupExtensionSettingService
     */
    get adGroupExtensionSettings() {
        const service = this.loadService("AdGroupExtensionSettingServiceClient");
        return {
            /**
             * @description create resources of type resources.IAdGroupExtensionSetting
             * @returns services.MutateAdGroupExtensionSettingsResponse
             */
            create: async (adGroupExtensionSettings, options) => {
                const ops = this.buildOperations("create", adGroupExtensionSettings);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AdGroupExtensionSettingService.mutateAdGroupExtensionSettings",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAdGroupExtensionSettings(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.IAdGroupExtensionSetting
             * @returns services.MutateAdGroupExtensionSettingsResponse
             */
            update: async (adGroupExtensionSettings, options) => {
                const ops = this.buildOperations("update", adGroupExtensionSettings, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.AdGroupExtensionSetting);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AdGroupExtensionSettingService.mutateAdGroupExtensionSettings",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAdGroupExtensionSettings(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateAdGroupExtensionSettingsResponse
             */
            remove: async (adGroupExtensionSettings, options) => {
                const ops = this.buildOperations("remove", adGroupExtensionSettings);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AdGroupExtensionSettingService.mutateAdGroupExtensionSettings",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAdGroupExtensionSettings(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/AdGroupFeedService
     */
    get adGroupFeeds() {
        const service = this.loadService("AdGroupFeedServiceClient");
        return {
            /**
             * @description create resources of type resources.IAdGroupFeed
             * @returns services.MutateAdGroupFeedsResponse
             */
            create: async (adGroupFeeds, options) => {
                const ops = this.buildOperations("create", adGroupFeeds);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AdGroupFeedService.mutateAdGroupFeeds",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAdGroupFeeds(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.IAdGroupFeed
             * @returns services.MutateAdGroupFeedsResponse
             */
            update: async (adGroupFeeds, options) => {
                const ops = this.buildOperations("update", adGroupFeeds, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.AdGroupFeed);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AdGroupFeedService.mutateAdGroupFeeds",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAdGroupFeeds(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateAdGroupFeedsResponse
             */
            remove: async (adGroupFeeds, options) => {
                const ops = this.buildOperations("remove", adGroupFeeds);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AdGroupFeedService.mutateAdGroupFeeds",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAdGroupFeeds(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/AdGroupLabelService
     */
    get adGroupLabels() {
        const service = this.loadService("AdGroupLabelServiceClient");
        return {
            /**
             * @description create resources of type resources.IAdGroupLabel
             * @returns services.MutateAdGroupLabelsResponse
             */
            create: async (adGroupLabels, options) => {
                const ops = this.buildOperations("create", adGroupLabels);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AdGroupLabelService.mutateAdGroupLabels",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAdGroupLabels(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateAdGroupLabelsResponse
             */
            remove: async (adGroupLabels, options) => {
                const ops = this.buildOperations("remove", adGroupLabels);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AdGroupLabelService.mutateAdGroupLabels",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAdGroupLabels(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/AdGroupService
     */
    get adGroups() {
        const service = this.loadService("AdGroupServiceClient");
        return {
            /**
             * @description create resources of type resources.IAdGroup
             * @returns services.MutateAdGroupsResponse
             */
            create: async (adGroups, options) => {
                const ops = this.buildOperations("create", adGroups);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AdGroupService.mutateAdGroups",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAdGroups(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.IAdGroup
             * @returns services.MutateAdGroupsResponse
             */
            update: async (adGroups, options) => {
                const ops = this.buildOperations("update", adGroups, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.AdGroup);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AdGroupService.mutateAdGroups",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAdGroups(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateAdGroupsResponse
             */
            remove: async (adGroups, options) => {
                const ops = this.buildOperations("remove", adGroups);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AdGroupService.mutateAdGroups",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAdGroups(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/AdParameterService
     */
    get adParameters() {
        const service = this.loadService("AdParameterServiceClient");
        return {
            /**
             * @description create resources of type resources.IAdParameter
             * @returns services.MutateAdParametersResponse
             */
            create: async (adParameters, options) => {
                const ops = this.buildOperations("create", adParameters);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AdParameterService.mutateAdParameters",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAdParameters(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.IAdParameter
             * @returns services.MutateAdParametersResponse
             */
            update: async (adParameters, options) => {
                const ops = this.buildOperations("update", adParameters, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.AdParameter);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AdParameterService.mutateAdParameters",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAdParameters(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateAdParametersResponse
             */
            remove: async (adParameters, options) => {
                const ops = this.buildOperations("remove", adParameters);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AdParameterService.mutateAdParameters",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAdParameters(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/AdService
     */
    get ads() {
        const service = this.loadService("AdServiceClient");
        return {
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v14/AdService#getad
             */
            getAd: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AdService.GetAd",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.getAd(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.IAd
             * @returns services.MutateAdsResponse
             */
            update: async (ads, options) => {
                const ops = this.buildOperations("update", ads, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.Ad);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AdService.mutateAds",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAds(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/AssetGroupAssetService
     */
    get assetGroupAssets() {
        const service = this.loadService("AssetGroupAssetServiceClient");
        return {
            /**
             * @description create resources of type resources.IAssetGroupAsset
             * @returns services.MutateAssetGroupAssetsResponse
             */
            create: async (assetGroupAssets, options) => {
                const ops = this.buildOperations("create", assetGroupAssets);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AssetGroupAssetService.mutateAssetGroupAssets",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAssetGroupAssets(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.IAssetGroupAsset
             * @returns services.MutateAssetGroupAssetsResponse
             */
            update: async (assetGroupAssets, options) => {
                const ops = this.buildOperations("update", assetGroupAssets, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.AssetGroupAsset);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AssetGroupAssetService.mutateAssetGroupAssets",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAssetGroupAssets(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateAssetGroupAssetsResponse
             */
            remove: async (assetGroupAssets, options) => {
                const ops = this.buildOperations("remove", assetGroupAssets);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AssetGroupAssetService.mutateAssetGroupAssets",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAssetGroupAssets(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/AssetGroupListingGroupFilterService
     */
    get assetGroupListingGroupFilters() {
        const service = this.loadService("AssetGroupListingGroupFilterServiceClient");
        return {
            /**
             * @description create resources of type resources.IAssetGroupListingGroupFilter
             * @returns services.MutateAssetGroupListingGroupFiltersResponse
             */
            create: async (assetGroupListingGroupFilters, options) => {
                const ops = this.buildOperations("create", assetGroupListingGroupFilters);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AssetGroupListingGroupFilterService.mutateAssetGroupListingGroupFilters",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAssetGroupListingGroupFilters(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.IAssetGroupListingGroupFilter
             * @returns services.MutateAssetGroupListingGroupFiltersResponse
             */
            update: async (assetGroupListingGroupFilters, options) => {
                const ops = this.buildOperations("update", assetGroupListingGroupFilters, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.AssetGroupListingGroupFilter);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AssetGroupListingGroupFilterService.mutateAssetGroupListingGroupFilters",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAssetGroupListingGroupFilters(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateAssetGroupListingGroupFiltersResponse
             */
            remove: async (assetGroupListingGroupFilters, options) => {
                const ops = this.buildOperations("remove", assetGroupListingGroupFilters);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AssetGroupListingGroupFilterService.mutateAssetGroupListingGroupFilters",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAssetGroupListingGroupFilters(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/AssetGroupService
     */
    get assetGroups() {
        const service = this.loadService("AssetGroupServiceClient");
        return {
            /**
             * @description create resources of type resources.IAssetGroup
             * @returns services.MutateAssetGroupsResponse
             */
            create: async (assetGroups, options) => {
                const ops = this.buildOperations("create", assetGroups);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AssetGroupService.mutateAssetGroups",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAssetGroups(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.IAssetGroup
             * @returns services.MutateAssetGroupsResponse
             */
            update: async (assetGroups, options) => {
                const ops = this.buildOperations("update", assetGroups, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.AssetGroup);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AssetGroupService.mutateAssetGroups",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAssetGroups(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateAssetGroupsResponse
             */
            remove: async (assetGroups, options) => {
                const ops = this.buildOperations("remove", assetGroups);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AssetGroupService.mutateAssetGroups",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAssetGroups(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/AssetGroupSignalService
     */
    get assetGroupSignals() {
        const service = this.loadService("AssetGroupSignalServiceClient");
        return {
            /**
             * @description create resources of type resources.IAssetGroupSignal
             * @returns services.MutateAssetGroupSignalsResponse
             */
            create: async (assetGroupSignals, options) => {
                const ops = this.buildOperations("create", assetGroupSignals);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AssetGroupSignalService.mutateAssetGroupSignals",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAssetGroupSignals(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateAssetGroupSignalsResponse
             */
            remove: async (assetGroupSignals, options) => {
                const ops = this.buildOperations("remove", assetGroupSignals);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AssetGroupSignalService.mutateAssetGroupSignals",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAssetGroupSignals(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/AssetService
     */
    get assets() {
        const service = this.loadService("AssetServiceClient");
        return {
            /**
             * @description create resources of type resources.IAsset
             * @returns services.MutateAssetsResponse
             */
            create: async (assets, options) => {
                const ops = this.buildOperations("create", assets);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AssetService.mutateAssets",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAssets(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.IAsset
             * @returns services.MutateAssetsResponse
             */
            update: async (assets, options) => {
                const ops = this.buildOperations("update", assets, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.Asset);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AssetService.mutateAssets",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAssets(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/AssetSetAssetService
     */
    get assetSetAssets() {
        const service = this.loadService("AssetSetAssetServiceClient");
        return {
            /**
             * @description create resources of type resources.IAssetSetAsset
             * @returns services.MutateAssetSetAssetsResponse
             */
            create: async (assetSetAssets, options) => {
                const ops = this.buildOperations("create", assetSetAssets);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AssetSetAssetService.mutateAssetSetAssets",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAssetSetAssets(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateAssetSetAssetsResponse
             */
            remove: async (assetSetAssets, options) => {
                const ops = this.buildOperations("remove", assetSetAssets);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AssetSetAssetService.mutateAssetSetAssets",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAssetSetAssets(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/AssetSetService
     */
    get assetSets() {
        const service = this.loadService("AssetSetServiceClient");
        return {
            /**
             * @description create resources of type resources.IAssetSet
             * @returns services.MutateAssetSetsResponse
             */
            create: async (assetSets, options) => {
                const ops = this.buildOperations("create", assetSets);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AssetSetService.mutateAssetSets",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAssetSets(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.IAssetSet
             * @returns services.MutateAssetSetsResponse
             */
            update: async (assetSets, options) => {
                const ops = this.buildOperations("update", assetSets, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.AssetSet);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AssetSetService.mutateAssetSets",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAssetSets(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateAssetSetsResponse
             */
            remove: async (assetSets, options) => {
                const ops = this.buildOperations("remove", assetSets);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AssetSetService.mutateAssetSets",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAssetSets(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/AudienceInsightsService
     */
    get audienceInsights() {
        const service = this.loadService("AudienceInsightsServiceClient");
        return {
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v14/AudienceInsightsService#generateinsightsfinderreport
             */
            generateInsightsFinderReport: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AudienceInsightsService.GenerateInsightsFinderReport",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.generateInsightsFinderReport(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v14/AudienceInsightsService#listaudienceinsightsattributes
             */
            listAudienceInsightsAttributes: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AudienceInsightsService.ListAudienceInsightsAttributes",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.listAudienceInsightsAttributes(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v14/AudienceInsightsService#listinsightseligibledates
             */
            listInsightsEligibleDates: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AudienceInsightsService.ListInsightsEligibleDates",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.listInsightsEligibleDates(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v14/AudienceInsightsService#generateaudiencecompositioninsights
             */
            generateAudienceCompositionInsights: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AudienceInsightsService.GenerateAudienceCompositionInsights",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.generateAudienceCompositionInsights(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/AudienceService
     */
    get audiences() {
        const service = this.loadService("AudienceServiceClient");
        return {
            /**
             * @description create resources of type resources.IAudience
             * @returns services.MutateAudiencesResponse
             */
            create: async (audiences, options) => {
                const ops = this.buildOperations("create", audiences);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AudienceService.mutateAudiences",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAudiences(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.IAudience
             * @returns services.MutateAudiencesResponse
             */
            update: async (audiences, options) => {
                const ops = this.buildOperations("update", audiences, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.Audience);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AudienceService.mutateAudiences",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAudiences(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/BatchJobService
     */
    get batchJobs() {
        const service = this.loadService("BatchJobServiceClient");
        return {
            /**
             * @description create resources of type resources.IBatchJob
             * @returns services.MutateBatchJobResponse
             */
            create: async (batchJobs, options) => {
                const ops = this.buildOperations("create", batchJobs);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "BatchJobService.mutateBatchJob",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateBatchJob(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateBatchJobResponse
             */
            remove: async (batchJobs, options) => {
                const ops = this.buildOperations("remove", batchJobs);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "BatchJobService.mutateBatchJob",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateBatchJob(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v14/BatchJobService#listbatchjobresults
             */
            listBatchJobResults: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "BatchJobService.ListBatchJobResults",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.listBatchJobResults(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v14/BatchJobService#runbatchjob
             */
            runBatchJob: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "BatchJobService.RunBatchJob",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.runBatchJob(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v14/BatchJobService#addbatchjoboperations
             */
            addBatchJobOperations: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "BatchJobService.AddBatchJobOperations",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.addBatchJobOperations(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/BiddingDataExclusionService
     */
    get biddingDataExclusions() {
        const service = this.loadService("BiddingDataExclusionServiceClient");
        return {
            /**
             * @description create resources of type resources.IBiddingDataExclusion
             * @returns services.MutateBiddingDataExclusionsResponse
             */
            create: async (biddingDataExclusions, options) => {
                const ops = this.buildOperations("create", biddingDataExclusions);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "BiddingDataExclusionService.mutateBiddingDataExclusions",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateBiddingDataExclusions(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.IBiddingDataExclusion
             * @returns services.MutateBiddingDataExclusionsResponse
             */
            update: async (biddingDataExclusions, options) => {
                const ops = this.buildOperations("update", biddingDataExclusions, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.BiddingDataExclusion);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "BiddingDataExclusionService.mutateBiddingDataExclusions",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateBiddingDataExclusions(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateBiddingDataExclusionsResponse
             */
            remove: async (biddingDataExclusions, options) => {
                const ops = this.buildOperations("remove", biddingDataExclusions);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "BiddingDataExclusionService.mutateBiddingDataExclusions",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateBiddingDataExclusions(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/BiddingSeasonalityAdjustmentService
     */
    get biddingSeasonalityAdjustments() {
        const service = this.loadService("BiddingSeasonalityAdjustmentServiceClient");
        return {
            /**
             * @description create resources of type resources.IBiddingSeasonalityAdjustment
             * @returns services.MutateBiddingSeasonalityAdjustmentsResponse
             */
            create: async (biddingSeasonalityAdjustments, options) => {
                const ops = this.buildOperations("create", biddingSeasonalityAdjustments);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "BiddingSeasonalityAdjustmentService.mutateBiddingSeasonalityAdjustments",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateBiddingSeasonalityAdjustments(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.IBiddingSeasonalityAdjustment
             * @returns services.MutateBiddingSeasonalityAdjustmentsResponse
             */
            update: async (biddingSeasonalityAdjustments, options) => {
                const ops = this.buildOperations("update", biddingSeasonalityAdjustments, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.BiddingSeasonalityAdjustment);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "BiddingSeasonalityAdjustmentService.mutateBiddingSeasonalityAdjustments",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateBiddingSeasonalityAdjustments(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateBiddingSeasonalityAdjustmentsResponse
             */
            remove: async (biddingSeasonalityAdjustments, options) => {
                const ops = this.buildOperations("remove", biddingSeasonalityAdjustments);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "BiddingSeasonalityAdjustmentService.mutateBiddingSeasonalityAdjustments",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateBiddingSeasonalityAdjustments(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/BiddingStrategyService
     */
    get biddingStrategies() {
        const service = this.loadService("BiddingStrategyServiceClient");
        return {
            /**
             * @description create resources of type resources.IBiddingStrategy
             * @returns services.MutateBiddingStrategiesResponse
             */
            create: async (biddingStrategies, options) => {
                const ops = this.buildOperations("create", biddingStrategies);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "BiddingStrategyService.mutateBiddingStrategies",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateBiddingStrategies(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.IBiddingStrategy
             * @returns services.MutateBiddingStrategiesResponse
             */
            update: async (biddingStrategies, options) => {
                const ops = this.buildOperations("update", biddingStrategies, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.BiddingStrategy);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "BiddingStrategyService.mutateBiddingStrategies",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateBiddingStrategies(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateBiddingStrategiesResponse
             */
            remove: async (biddingStrategies, options) => {
                const ops = this.buildOperations("remove", biddingStrategies);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "BiddingStrategyService.mutateBiddingStrategies",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateBiddingStrategies(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/CampaignAssetService
     */
    get campaignAssets() {
        const service = this.loadService("CampaignAssetServiceClient");
        return {
            /**
             * @description create resources of type resources.ICampaignAsset
             * @returns services.MutateCampaignAssetsResponse
             */
            create: async (campaignAssets, options) => {
                const ops = this.buildOperations("create", campaignAssets);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CampaignAssetService.mutateCampaignAssets",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCampaignAssets(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.ICampaignAsset
             * @returns services.MutateCampaignAssetsResponse
             */
            update: async (campaignAssets, options) => {
                const ops = this.buildOperations("update", campaignAssets, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.CampaignAsset);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CampaignAssetService.mutateCampaignAssets",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCampaignAssets(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateCampaignAssetsResponse
             */
            remove: async (campaignAssets, options) => {
                const ops = this.buildOperations("remove", campaignAssets);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CampaignAssetService.mutateCampaignAssets",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCampaignAssets(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/CampaignAssetSetService
     */
    get campaignAssetSets() {
        const service = this.loadService("CampaignAssetSetServiceClient");
        return {
            /**
             * @description create resources of type resources.ICampaignAssetSet
             * @returns services.MutateCampaignAssetSetsResponse
             */
            create: async (campaignAssetSets, options) => {
                const ops = this.buildOperations("create", campaignAssetSets);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CampaignAssetSetService.mutateCampaignAssetSets",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCampaignAssetSets(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateCampaignAssetSetsResponse
             */
            remove: async (campaignAssetSets, options) => {
                const ops = this.buildOperations("remove", campaignAssetSets);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CampaignAssetSetService.mutateCampaignAssetSets",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCampaignAssetSets(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/CampaignBidModifierService
     */
    get campaignBidModifiers() {
        const service = this.loadService("CampaignBidModifierServiceClient");
        return {
            /**
             * @description create resources of type resources.ICampaignBidModifier
             * @returns services.MutateCampaignBidModifiersResponse
             */
            create: async (campaignBidModifiers, options) => {
                const ops = this.buildOperations("create", campaignBidModifiers);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CampaignBidModifierService.mutateCampaignBidModifiers",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCampaignBidModifiers(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.ICampaignBidModifier
             * @returns services.MutateCampaignBidModifiersResponse
             */
            update: async (campaignBidModifiers, options) => {
                const ops = this.buildOperations("update", campaignBidModifiers, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.CampaignBidModifier);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CampaignBidModifierService.mutateCampaignBidModifiers",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCampaignBidModifiers(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateCampaignBidModifiersResponse
             */
            remove: async (campaignBidModifiers, options) => {
                const ops = this.buildOperations("remove", campaignBidModifiers);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CampaignBidModifierService.mutateCampaignBidModifiers",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCampaignBidModifiers(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/CampaignBudgetService
     */
    get campaignBudgets() {
        const service = this.loadService("CampaignBudgetServiceClient");
        return {
            /**
             * @description create resources of type resources.ICampaignBudget
             * @returns services.MutateCampaignBudgetsResponse
             */
            create: async (campaignBudgets, options) => {
                const ops = this.buildOperations("create", campaignBudgets);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CampaignBudgetService.mutateCampaignBudgets",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCampaignBudgets(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.ICampaignBudget
             * @returns services.MutateCampaignBudgetsResponse
             */
            update: async (campaignBudgets, options) => {
                const ops = this.buildOperations("update", campaignBudgets, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.CampaignBudget);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CampaignBudgetService.mutateCampaignBudgets",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCampaignBudgets(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateCampaignBudgetsResponse
             */
            remove: async (campaignBudgets, options) => {
                const ops = this.buildOperations("remove", campaignBudgets);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CampaignBudgetService.mutateCampaignBudgets",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCampaignBudgets(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/CampaignConversionGoalService
     */
    get campaignConversionGoals() {
        const service = this.loadService("CampaignConversionGoalServiceClient");
        return {
            /**
             * @description update resources of type resources.ICampaignConversionGoal
             * @returns services.MutateCampaignConversionGoalsResponse
             */
            update: async (campaignConversionGoals, options) => {
                const ops = this.buildOperations("update", campaignConversionGoals, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.CampaignConversionGoal);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CampaignConversionGoalService.mutateCampaignConversionGoals",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCampaignConversionGoals(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/CampaignCriterionService
     */
    get campaignCriteria() {
        const service = this.loadService("CampaignCriterionServiceClient");
        return {
            /**
             * @description create resources of type resources.ICampaignCriterion
             * @returns services.MutateCampaignCriteriaResponse
             */
            create: async (campaignCriteria, options) => {
                const ops = this.buildOperations("create", campaignCriteria);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CampaignCriterionService.mutateCampaignCriteria",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCampaignCriteria(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.ICampaignCriterion
             * @returns services.MutateCampaignCriteriaResponse
             */
            update: async (campaignCriteria, options) => {
                const ops = this.buildOperations("update", campaignCriteria, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.CampaignCriterion);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CampaignCriterionService.mutateCampaignCriteria",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCampaignCriteria(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateCampaignCriteriaResponse
             */
            remove: async (campaignCriteria, options) => {
                const ops = this.buildOperations("remove", campaignCriteria);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CampaignCriterionService.mutateCampaignCriteria",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCampaignCriteria(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/CampaignCustomizerService
     */
    get campaignCustomizers() {
        const service = this.loadService("CampaignCustomizerServiceClient");
        return {
            /**
             * @description create resources of type resources.ICampaignCustomizer
             * @returns services.MutateCampaignCustomizersResponse
             */
            create: async (campaignCustomizers, options) => {
                const ops = this.buildOperations("create", campaignCustomizers);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CampaignCustomizerService.mutateCampaignCustomizers",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCampaignCustomizers(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateCampaignCustomizersResponse
             */
            remove: async (campaignCustomizers, options) => {
                const ops = this.buildOperations("remove", campaignCustomizers);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CampaignCustomizerService.mutateCampaignCustomizers",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCampaignCustomizers(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/CampaignDraftService
     */
    get campaignDrafts() {
        const service = this.loadService("CampaignDraftServiceClient");
        return {
            /**
             * @description create resources of type resources.ICampaignDraft
             * @returns services.MutateCampaignDraftsResponse
             */
            create: async (campaignDrafts, options) => {
                const ops = this.buildOperations("create", campaignDrafts);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CampaignDraftService.mutateCampaignDrafts",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCampaignDrafts(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.ICampaignDraft
             * @returns services.MutateCampaignDraftsResponse
             */
            update: async (campaignDrafts, options) => {
                const ops = this.buildOperations("update", campaignDrafts, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.CampaignDraft);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CampaignDraftService.mutateCampaignDrafts",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCampaignDrafts(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateCampaignDraftsResponse
             */
            remove: async (campaignDrafts, options) => {
                const ops = this.buildOperations("remove", campaignDrafts);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CampaignDraftService.mutateCampaignDrafts",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCampaignDrafts(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v14/CampaignDraftService#promotecampaigndraft
             */
            promoteCampaignDraft: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CampaignDraftService.PromoteCampaignDraft",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.promoteCampaignDraft(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v14/CampaignDraftService#listcampaigndraftasyncerrors
             */
            listCampaignDraftAsyncErrors: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CampaignDraftService.ListCampaignDraftAsyncErrors",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.listCampaignDraftAsyncErrors(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/CampaignExtensionSettingService
     */
    get campaignExtensionSettings() {
        const service = this.loadService("CampaignExtensionSettingServiceClient");
        return {
            /**
             * @description create resources of type resources.ICampaignExtensionSetting
             * @returns services.MutateCampaignExtensionSettingsResponse
             */
            create: async (campaignExtensionSettings, options) => {
                const ops = this.buildOperations("create", campaignExtensionSettings);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CampaignExtensionSettingService.mutateCampaignExtensionSettings",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCampaignExtensionSettings(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.ICampaignExtensionSetting
             * @returns services.MutateCampaignExtensionSettingsResponse
             */
            update: async (campaignExtensionSettings, options) => {
                const ops = this.buildOperations("update", campaignExtensionSettings, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.CampaignExtensionSetting);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CampaignExtensionSettingService.mutateCampaignExtensionSettings",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCampaignExtensionSettings(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateCampaignExtensionSettingsResponse
             */
            remove: async (campaignExtensionSettings, options) => {
                const ops = this.buildOperations("remove", campaignExtensionSettings);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CampaignExtensionSettingService.mutateCampaignExtensionSettings",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCampaignExtensionSettings(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/CampaignFeedService
     */
    get campaignFeeds() {
        const service = this.loadService("CampaignFeedServiceClient");
        return {
            /**
             * @description create resources of type resources.ICampaignFeed
             * @returns services.MutateCampaignFeedsResponse
             */
            create: async (campaignFeeds, options) => {
                const ops = this.buildOperations("create", campaignFeeds);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CampaignFeedService.mutateCampaignFeeds",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCampaignFeeds(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.ICampaignFeed
             * @returns services.MutateCampaignFeedsResponse
             */
            update: async (campaignFeeds, options) => {
                const ops = this.buildOperations("update", campaignFeeds, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.CampaignFeed);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CampaignFeedService.mutateCampaignFeeds",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCampaignFeeds(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateCampaignFeedsResponse
             */
            remove: async (campaignFeeds, options) => {
                const ops = this.buildOperations("remove", campaignFeeds);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CampaignFeedService.mutateCampaignFeeds",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCampaignFeeds(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/CampaignGroupService
     */
    get campaignGroups() {
        const service = this.loadService("CampaignGroupServiceClient");
        return {
            /**
             * @description create resources of type resources.ICampaignGroup
             * @returns services.MutateCampaignGroupsResponse
             */
            create: async (campaignGroups, options) => {
                const ops = this.buildOperations("create", campaignGroups);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CampaignGroupService.mutateCampaignGroups",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCampaignGroups(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.ICampaignGroup
             * @returns services.MutateCampaignGroupsResponse
             */
            update: async (campaignGroups, options) => {
                const ops = this.buildOperations("update", campaignGroups, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.CampaignGroup);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CampaignGroupService.mutateCampaignGroups",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCampaignGroups(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateCampaignGroupsResponse
             */
            remove: async (campaignGroups, options) => {
                const ops = this.buildOperations("remove", campaignGroups);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CampaignGroupService.mutateCampaignGroups",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCampaignGroups(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/CampaignLabelService
     */
    get campaignLabels() {
        const service = this.loadService("CampaignLabelServiceClient");
        return {
            /**
             * @description create resources of type resources.ICampaignLabel
             * @returns services.MutateCampaignLabelsResponse
             */
            create: async (campaignLabels, options) => {
                const ops = this.buildOperations("create", campaignLabels);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CampaignLabelService.mutateCampaignLabels",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCampaignLabels(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateCampaignLabelsResponse
             */
            remove: async (campaignLabels, options) => {
                const ops = this.buildOperations("remove", campaignLabels);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CampaignLabelService.mutateCampaignLabels",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCampaignLabels(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/CampaignService
     */
    get campaigns() {
        const service = this.loadService("CampaignServiceClient");
        return {
            /**
             * @description create resources of type resources.ICampaign
             * @returns services.MutateCampaignsResponse
             */
            create: async (campaigns, options) => {
                const ops = this.buildOperations("create", campaigns);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CampaignService.mutateCampaigns",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCampaigns(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.ICampaign
             * @returns services.MutateCampaignsResponse
             */
            update: async (campaigns, options) => {
                const ops = this.buildOperations("update", campaigns, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.Campaign);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CampaignService.mutateCampaigns",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCampaigns(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateCampaignsResponse
             */
            remove: async (campaigns, options) => {
                const ops = this.buildOperations("remove", campaigns);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CampaignService.mutateCampaigns",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCampaigns(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/CampaignSharedSetService
     */
    get campaignSharedSets() {
        const service = this.loadService("CampaignSharedSetServiceClient");
        return {
            /**
             * @description create resources of type resources.ICampaignSharedSet
             * @returns services.MutateCampaignSharedSetsResponse
             */
            create: async (campaignSharedSets, options) => {
                const ops = this.buildOperations("create", campaignSharedSets);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CampaignSharedSetService.mutateCampaignSharedSets",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCampaignSharedSets(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateCampaignSharedSetsResponse
             */
            remove: async (campaignSharedSets, options) => {
                const ops = this.buildOperations("remove", campaignSharedSets);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CampaignSharedSetService.mutateCampaignSharedSets",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCampaignSharedSets(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/ConversionActionService
     */
    get conversionActions() {
        const service = this.loadService("ConversionActionServiceClient");
        return {
            /**
             * @description create resources of type resources.IConversionAction
             * @returns services.MutateConversionActionsResponse
             */
            create: async (conversionActions, options) => {
                const ops = this.buildOperations("create", conversionActions);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "ConversionActionService.mutateConversionActions",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateConversionActions(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.IConversionAction
             * @returns services.MutateConversionActionsResponse
             */
            update: async (conversionActions, options) => {
                const ops = this.buildOperations("update", conversionActions, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.ConversionAction);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "ConversionActionService.mutateConversionActions",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateConversionActions(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateConversionActionsResponse
             */
            remove: async (conversionActions, options) => {
                const ops = this.buildOperations("remove", conversionActions);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "ConversionActionService.mutateConversionActions",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateConversionActions(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/ConversionCustomVariableService
     */
    get conversionCustomVariables() {
        const service = this.loadService("ConversionCustomVariableServiceClient");
        return {
            /**
             * @description create resources of type resources.IConversionCustomVariable
             * @returns services.MutateConversionCustomVariablesResponse
             */
            create: async (conversionCustomVariables, options) => {
                const ops = this.buildOperations("create", conversionCustomVariables);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "ConversionCustomVariableService.mutateConversionCustomVariables",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateConversionCustomVariables(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.IConversionCustomVariable
             * @returns services.MutateConversionCustomVariablesResponse
             */
            update: async (conversionCustomVariables, options) => {
                const ops = this.buildOperations("update", conversionCustomVariables, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.ConversionCustomVariable);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "ConversionCustomVariableService.mutateConversionCustomVariables",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateConversionCustomVariables(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/ConversionGoalCampaignConfigService
     */
    get conversionGoalCampaignConfigs() {
        const service = this.loadService("ConversionGoalCampaignConfigServiceClient");
        return {
            /**
             * @description update resources of type resources.IConversionGoalCampaignConfig
             * @returns services.MutateConversionGoalCampaignConfigsResponse
             */
            update: async (conversionGoalCampaignConfigs, options) => {
                const ops = this.buildOperations("update", conversionGoalCampaignConfigs, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.ConversionGoalCampaignConfig);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "ConversionGoalCampaignConfigService.mutateConversionGoalCampaignConfigs",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateConversionGoalCampaignConfigs(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/ConversionValueRuleService
     */
    get conversionValueRules() {
        const service = this.loadService("ConversionValueRuleServiceClient");
        return {
            /**
             * @description create resources of type resources.IConversionValueRule
             * @returns services.MutateConversionValueRulesResponse
             */
            create: async (conversionValueRules, options) => {
                const ops = this.buildOperations("create", conversionValueRules);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "ConversionValueRuleService.mutateConversionValueRules",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateConversionValueRules(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.IConversionValueRule
             * @returns services.MutateConversionValueRulesResponse
             */
            update: async (conversionValueRules, options) => {
                const ops = this.buildOperations("update", conversionValueRules, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.ConversionValueRule);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "ConversionValueRuleService.mutateConversionValueRules",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateConversionValueRules(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateConversionValueRulesResponse
             */
            remove: async (conversionValueRules, options) => {
                const ops = this.buildOperations("remove", conversionValueRules);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "ConversionValueRuleService.mutateConversionValueRules",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateConversionValueRules(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/ConversionValueRuleSetService
     */
    get conversionValueRuleSets() {
        const service = this.loadService("ConversionValueRuleSetServiceClient");
        return {
            /**
             * @description create resources of type resources.IConversionValueRuleSet
             * @returns services.MutateConversionValueRuleSetsResponse
             */
            create: async (conversionValueRuleSets, options) => {
                const ops = this.buildOperations("create", conversionValueRuleSets);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "ConversionValueRuleSetService.mutateConversionValueRuleSets",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateConversionValueRuleSets(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.IConversionValueRuleSet
             * @returns services.MutateConversionValueRuleSetsResponse
             */
            update: async (conversionValueRuleSets, options) => {
                const ops = this.buildOperations("update", conversionValueRuleSets, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.ConversionValueRuleSet);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "ConversionValueRuleSetService.mutateConversionValueRuleSets",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateConversionValueRuleSets(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateConversionValueRuleSetsResponse
             */
            remove: async (conversionValueRuleSets, options) => {
                const ops = this.buildOperations("remove", conversionValueRuleSets);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "ConversionValueRuleSetService.mutateConversionValueRuleSets",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateConversionValueRuleSets(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/CustomConversionGoalService
     */
    get customConversionGoals() {
        const service = this.loadService("CustomConversionGoalServiceClient");
        return {
            /**
             * @description create resources of type resources.ICustomConversionGoal
             * @returns services.MutateCustomConversionGoalsResponse
             */
            create: async (customConversionGoals, options) => {
                const ops = this.buildOperations("create", customConversionGoals);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CustomConversionGoalService.mutateCustomConversionGoals",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCustomConversionGoals(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.ICustomConversionGoal
             * @returns services.MutateCustomConversionGoalsResponse
             */
            update: async (customConversionGoals, options) => {
                const ops = this.buildOperations("update", customConversionGoals, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.CustomConversionGoal);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CustomConversionGoalService.mutateCustomConversionGoals",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCustomConversionGoals(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateCustomConversionGoalsResponse
             */
            remove: async (customConversionGoals, options) => {
                const ops = this.buildOperations("remove", customConversionGoals);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CustomConversionGoalService.mutateCustomConversionGoals",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCustomConversionGoals(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/CustomerAssetService
     */
    get customerAssets() {
        const service = this.loadService("CustomerAssetServiceClient");
        return {
            /**
             * @description create resources of type resources.ICustomerAsset
             * @returns services.MutateCustomerAssetsResponse
             */
            create: async (customerAssets, options) => {
                const ops = this.buildOperations("create", customerAssets);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CustomerAssetService.mutateCustomerAssets",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCustomerAssets(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.ICustomerAsset
             * @returns services.MutateCustomerAssetsResponse
             */
            update: async (customerAssets, options) => {
                const ops = this.buildOperations("update", customerAssets, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.CustomerAsset);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CustomerAssetService.mutateCustomerAssets",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCustomerAssets(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateCustomerAssetsResponse
             */
            remove: async (customerAssets, options) => {
                const ops = this.buildOperations("remove", customerAssets);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CustomerAssetService.mutateCustomerAssets",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCustomerAssets(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/CustomerConversionGoalService
     */
    get customerConversionGoals() {
        const service = this.loadService("CustomerConversionGoalServiceClient");
        return {
            /**
             * @description update resources of type resources.ICustomerConversionGoal
             * @returns services.MutateCustomerConversionGoalsResponse
             */
            update: async (customerConversionGoals, options) => {
                const ops = this.buildOperations("update", customerConversionGoals, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.CustomerConversionGoal);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CustomerConversionGoalService.mutateCustomerConversionGoals",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCustomerConversionGoals(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/CustomerCustomizerService
     */
    get customerCustomizers() {
        const service = this.loadService("CustomerCustomizerServiceClient");
        return {
            /**
             * @description create resources of type resources.ICustomerCustomizer
             * @returns services.MutateCustomerCustomizersResponse
             */
            create: async (customerCustomizers, options) => {
                const ops = this.buildOperations("create", customerCustomizers);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CustomerCustomizerService.mutateCustomerCustomizers",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCustomerCustomizers(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateCustomerCustomizersResponse
             */
            remove: async (customerCustomizers, options) => {
                const ops = this.buildOperations("remove", customerCustomizers);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CustomerCustomizerService.mutateCustomerCustomizers",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCustomerCustomizers(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/CustomerExtensionSettingService
     */
    get customerExtensionSettings() {
        const service = this.loadService("CustomerExtensionSettingServiceClient");
        return {
            /**
             * @description create resources of type resources.ICustomerExtensionSetting
             * @returns services.MutateCustomerExtensionSettingsResponse
             */
            create: async (customerExtensionSettings, options) => {
                const ops = this.buildOperations("create", customerExtensionSettings);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CustomerExtensionSettingService.mutateCustomerExtensionSettings",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCustomerExtensionSettings(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.ICustomerExtensionSetting
             * @returns services.MutateCustomerExtensionSettingsResponse
             */
            update: async (customerExtensionSettings, options) => {
                const ops = this.buildOperations("update", customerExtensionSettings, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.CustomerExtensionSetting);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CustomerExtensionSettingService.mutateCustomerExtensionSettings",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCustomerExtensionSettings(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateCustomerExtensionSettingsResponse
             */
            remove: async (customerExtensionSettings, options) => {
                const ops = this.buildOperations("remove", customerExtensionSettings);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CustomerExtensionSettingService.mutateCustomerExtensionSettings",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCustomerExtensionSettings(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/CustomerFeedService
     */
    get customerFeeds() {
        const service = this.loadService("CustomerFeedServiceClient");
        return {
            /**
             * @description create resources of type resources.ICustomerFeed
             * @returns services.MutateCustomerFeedsResponse
             */
            create: async (customerFeeds, options) => {
                const ops = this.buildOperations("create", customerFeeds);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CustomerFeedService.mutateCustomerFeeds",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCustomerFeeds(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.ICustomerFeed
             * @returns services.MutateCustomerFeedsResponse
             */
            update: async (customerFeeds, options) => {
                const ops = this.buildOperations("update", customerFeeds, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.CustomerFeed);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CustomerFeedService.mutateCustomerFeeds",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCustomerFeeds(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateCustomerFeedsResponse
             */
            remove: async (customerFeeds, options) => {
                const ops = this.buildOperations("remove", customerFeeds);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CustomerFeedService.mutateCustomerFeeds",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCustomerFeeds(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/CustomerLabelService
     */
    get customerLabels() {
        const service = this.loadService("CustomerLabelServiceClient");
        return {
            /**
             * @description create resources of type resources.ICustomerLabel
             * @returns services.MutateCustomerLabelsResponse
             */
            create: async (customerLabels, options) => {
                const ops = this.buildOperations("create", customerLabels);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CustomerLabelService.mutateCustomerLabels",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCustomerLabels(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateCustomerLabelsResponse
             */
            remove: async (customerLabels, options) => {
                const ops = this.buildOperations("remove", customerLabels);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CustomerLabelService.mutateCustomerLabels",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCustomerLabels(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/CustomerNegativeCriterionService
     */
    get customerNegativeCriteria() {
        const service = this.loadService("CustomerNegativeCriterionServiceClient");
        return {
            /**
             * @description create resources of type resources.ICustomerNegativeCriterion
             * @returns services.MutateCustomerNegativeCriteriaResponse
             */
            create: async (customerNegativeCriteria, options) => {
                const ops = this.buildOperations("create", customerNegativeCriteria);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CustomerNegativeCriterionService.mutateCustomerNegativeCriteria",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCustomerNegativeCriteria(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateCustomerNegativeCriteriaResponse
             */
            remove: async (customerNegativeCriteria, options) => {
                const ops = this.buildOperations("remove", customerNegativeCriteria);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CustomerNegativeCriterionService.mutateCustomerNegativeCriteria",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCustomerNegativeCriteria(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/CustomerService
     */
    get customers() {
        const service = this.loadService("CustomerServiceClient");
        return {
            /**
             * @description update resources of type resources.ICustomer
             * @returns services.MutateCustomerResponse
             */
            update: async (customers, options) => {
                const ops = this.buildOperations("update", customers, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.Customer);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CustomerService.mutateCustomer",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCustomer(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v14/CustomerService#listaccessiblecustomers
             */
            listAccessibleCustomers: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CustomerService.ListAccessibleCustomers",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.listAccessibleCustomers(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v14/CustomerService#createcustomerclient
             */
            createCustomerClient: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CustomerService.CreateCustomerClient",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.createCustomerClient(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/CustomizerAttributeService
     */
    get customizerAttributes() {
        const service = this.loadService("CustomizerAttributeServiceClient");
        return {
            /**
             * @description create resources of type resources.ICustomizerAttribute
             * @returns services.MutateCustomizerAttributesResponse
             */
            create: async (customizerAttributes, options) => {
                const ops = this.buildOperations("create", customizerAttributes);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CustomizerAttributeService.mutateCustomizerAttributes",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCustomizerAttributes(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateCustomizerAttributesResponse
             */
            remove: async (customizerAttributes, options) => {
                const ops = this.buildOperations("remove", customizerAttributes);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CustomizerAttributeService.mutateCustomizerAttributes",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCustomizerAttributes(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/ExperimentArmService
     */
    get experimentArms() {
        const service = this.loadService("ExperimentArmServiceClient");
        return {
            /**
             * @description create resources of type resources.IExperimentArm
             * @returns services.MutateExperimentArmsResponse
             */
            create: async (experimentArms, options) => {
                const ops = this.buildOperations("create", experimentArms);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "ExperimentArmService.mutateExperimentArms",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateExperimentArms(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.IExperimentArm
             * @returns services.MutateExperimentArmsResponse
             */
            update: async (experimentArms, options) => {
                const ops = this.buildOperations("update", experimentArms, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.ExperimentArm);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "ExperimentArmService.mutateExperimentArms",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateExperimentArms(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateExperimentArmsResponse
             */
            remove: async (experimentArms, options) => {
                const ops = this.buildOperations("remove", experimentArms);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "ExperimentArmService.mutateExperimentArms",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateExperimentArms(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/ExperimentService
     */
    get experiments() {
        const service = this.loadService("ExperimentServiceClient");
        return {
            /**
             * @description create resources of type resources.IExperiment
             * @returns services.MutateExperimentsResponse
             */
            create: async (experiments, options) => {
                const ops = this.buildOperations("create", experiments);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "ExperimentService.mutateExperiments",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateExperiments(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.IExperiment
             * @returns services.MutateExperimentsResponse
             */
            update: async (experiments, options) => {
                const ops = this.buildOperations("update", experiments, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.Experiment);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "ExperimentService.mutateExperiments",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateExperiments(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateExperimentsResponse
             */
            remove: async (experiments, options) => {
                const ops = this.buildOperations("remove", experiments);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "ExperimentService.mutateExperiments",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateExperiments(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v14/ExperimentService#endexperiment
             */
            endExperiment: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "ExperimentService.EndExperiment",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.endExperiment(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v14/ExperimentService#listexperimentasyncerrors
             */
            listExperimentAsyncErrors: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "ExperimentService.ListExperimentAsyncErrors",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.listExperimentAsyncErrors(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v14/ExperimentService#graduateexperiment
             */
            graduateExperiment: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "ExperimentService.GraduateExperiment",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.graduateExperiment(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v14/ExperimentService#scheduleexperiment
             */
            scheduleExperiment: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "ExperimentService.ScheduleExperiment",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.scheduleExperiment(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v14/ExperimentService#promoteexperiment
             */
            promoteExperiment: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "ExperimentService.PromoteExperiment",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.promoteExperiment(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/ExtensionFeedItemService
     */
    get extensionFeedItems() {
        const service = this.loadService("ExtensionFeedItemServiceClient");
        return {
            /**
             * @description create resources of type resources.IExtensionFeedItem
             * @returns services.MutateExtensionFeedItemsResponse
             */
            create: async (extensionFeedItems, options) => {
                const ops = this.buildOperations("create", extensionFeedItems);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "ExtensionFeedItemService.mutateExtensionFeedItems",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateExtensionFeedItems(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.IExtensionFeedItem
             * @returns services.MutateExtensionFeedItemsResponse
             */
            update: async (extensionFeedItems, options) => {
                const ops = this.buildOperations("update", extensionFeedItems, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.ExtensionFeedItem);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "ExtensionFeedItemService.mutateExtensionFeedItems",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateExtensionFeedItems(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateExtensionFeedItemsResponse
             */
            remove: async (extensionFeedItems, options) => {
                const ops = this.buildOperations("remove", extensionFeedItems);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "ExtensionFeedItemService.mutateExtensionFeedItems",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateExtensionFeedItems(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/FeedItemService
     */
    get feedItems() {
        const service = this.loadService("FeedItemServiceClient");
        return {
            /**
             * @description create resources of type resources.IFeedItem
             * @returns services.MutateFeedItemsResponse
             */
            create: async (feedItems, options) => {
                const ops = this.buildOperations("create", feedItems);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "FeedItemService.mutateFeedItems",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateFeedItems(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.IFeedItem
             * @returns services.MutateFeedItemsResponse
             */
            update: async (feedItems, options) => {
                const ops = this.buildOperations("update", feedItems, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.FeedItem);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "FeedItemService.mutateFeedItems",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateFeedItems(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateFeedItemsResponse
             */
            remove: async (feedItems, options) => {
                const ops = this.buildOperations("remove", feedItems);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "FeedItemService.mutateFeedItems",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateFeedItems(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/FeedItemSetLinkService
     */
    get feedItemSetLinks() {
        const service = this.loadService("FeedItemSetLinkServiceClient");
        return {
            /**
             * @description create resources of type resources.IFeedItemSetLink
             * @returns services.MutateFeedItemSetLinksResponse
             */
            create: async (feedItemSetLinks, options) => {
                const ops = this.buildOperations("create", feedItemSetLinks);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "FeedItemSetLinkService.mutateFeedItemSetLinks",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateFeedItemSetLinks(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateFeedItemSetLinksResponse
             */
            remove: async (feedItemSetLinks, options) => {
                const ops = this.buildOperations("remove", feedItemSetLinks);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "FeedItemSetLinkService.mutateFeedItemSetLinks",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateFeedItemSetLinks(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/FeedItemSetService
     */
    get feedItemSets() {
        const service = this.loadService("FeedItemSetServiceClient");
        return {
            /**
             * @description create resources of type resources.IFeedItemSet
             * @returns services.MutateFeedItemSetsResponse
             */
            create: async (feedItemSets, options) => {
                const ops = this.buildOperations("create", feedItemSets);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "FeedItemSetService.mutateFeedItemSets",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateFeedItemSets(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.IFeedItemSet
             * @returns services.MutateFeedItemSetsResponse
             */
            update: async (feedItemSets, options) => {
                const ops = this.buildOperations("update", feedItemSets, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.FeedItemSet);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "FeedItemSetService.mutateFeedItemSets",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateFeedItemSets(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateFeedItemSetsResponse
             */
            remove: async (feedItemSets, options) => {
                const ops = this.buildOperations("remove", feedItemSets);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "FeedItemSetService.mutateFeedItemSets",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateFeedItemSets(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/FeedItemTargetService
     */
    get feedItemTargets() {
        const service = this.loadService("FeedItemTargetServiceClient");
        return {
            /**
             * @description create resources of type resources.IFeedItemTarget
             * @returns services.MutateFeedItemTargetsResponse
             */
            create: async (feedItemTargets, options) => {
                const ops = this.buildOperations("create", feedItemTargets);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "FeedItemTargetService.mutateFeedItemTargets",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateFeedItemTargets(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateFeedItemTargetsResponse
             */
            remove: async (feedItemTargets, options) => {
                const ops = this.buildOperations("remove", feedItemTargets);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "FeedItemTargetService.mutateFeedItemTargets",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateFeedItemTargets(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/FeedMappingService
     */
    get feedMappings() {
        const service = this.loadService("FeedMappingServiceClient");
        return {
            /**
             * @description create resources of type resources.IFeedMapping
             * @returns services.MutateFeedMappingsResponse
             */
            create: async (feedMappings, options) => {
                const ops = this.buildOperations("create", feedMappings);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "FeedMappingService.mutateFeedMappings",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateFeedMappings(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateFeedMappingsResponse
             */
            remove: async (feedMappings, options) => {
                const ops = this.buildOperations("remove", feedMappings);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "FeedMappingService.mutateFeedMappings",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateFeedMappings(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/FeedService
     */
    get feeds() {
        const service = this.loadService("FeedServiceClient");
        return {
            /**
             * @description create resources of type resources.IFeed
             * @returns services.MutateFeedsResponse
             */
            create: async (feeds, options) => {
                const ops = this.buildOperations("create", feeds);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "FeedService.mutateFeeds",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateFeeds(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.IFeed
             * @returns services.MutateFeedsResponse
             */
            update: async (feeds, options) => {
                const ops = this.buildOperations("update", feeds, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.Feed);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "FeedService.mutateFeeds",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateFeeds(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateFeedsResponse
             */
            remove: async (feeds, options) => {
                const ops = this.buildOperations("remove", feeds);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "FeedService.mutateFeeds",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateFeeds(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/KeywordPlanAdGroupKeywordService
     */
    get keywordPlanAdGroupKeywords() {
        const service = this.loadService("KeywordPlanAdGroupKeywordServiceClient");
        return {
            /**
             * @description create resources of type resources.IKeywordPlanAdGroupKeyword
             * @returns services.MutateKeywordPlanAdGroupKeywordsResponse
             */
            create: async (keywordPlanAdGroupKeywords, options) => {
                const ops = this.buildOperations("create", keywordPlanAdGroupKeywords);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "KeywordPlanAdGroupKeywordService.mutateKeywordPlanAdGroupKeywords",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateKeywordPlanAdGroupKeywords(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.IKeywordPlanAdGroupKeyword
             * @returns services.MutateKeywordPlanAdGroupKeywordsResponse
             */
            update: async (keywordPlanAdGroupKeywords, options) => {
                const ops = this.buildOperations("update", keywordPlanAdGroupKeywords, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.KeywordPlanAdGroupKeyword);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "KeywordPlanAdGroupKeywordService.mutateKeywordPlanAdGroupKeywords",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateKeywordPlanAdGroupKeywords(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateKeywordPlanAdGroupKeywordsResponse
             */
            remove: async (keywordPlanAdGroupKeywords, options) => {
                const ops = this.buildOperations("remove", keywordPlanAdGroupKeywords);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "KeywordPlanAdGroupKeywordService.mutateKeywordPlanAdGroupKeywords",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateKeywordPlanAdGroupKeywords(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/KeywordPlanAdGroupService
     */
    get keywordPlanAdGroups() {
        const service = this.loadService("KeywordPlanAdGroupServiceClient");
        return {
            /**
             * @description create resources of type resources.IKeywordPlanAdGroup
             * @returns services.MutateKeywordPlanAdGroupsResponse
             */
            create: async (keywordPlanAdGroups, options) => {
                const ops = this.buildOperations("create", keywordPlanAdGroups);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "KeywordPlanAdGroupService.mutateKeywordPlanAdGroups",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateKeywordPlanAdGroups(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.IKeywordPlanAdGroup
             * @returns services.MutateKeywordPlanAdGroupsResponse
             */
            update: async (keywordPlanAdGroups, options) => {
                const ops = this.buildOperations("update", keywordPlanAdGroups, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.KeywordPlanAdGroup);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "KeywordPlanAdGroupService.mutateKeywordPlanAdGroups",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateKeywordPlanAdGroups(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateKeywordPlanAdGroupsResponse
             */
            remove: async (keywordPlanAdGroups, options) => {
                const ops = this.buildOperations("remove", keywordPlanAdGroups);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "KeywordPlanAdGroupService.mutateKeywordPlanAdGroups",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateKeywordPlanAdGroups(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/KeywordPlanCampaignKeywordService
     */
    get keywordPlanCampaignKeywords() {
        const service = this.loadService("KeywordPlanCampaignKeywordServiceClient");
        return {
            /**
             * @description create resources of type resources.IKeywordPlanCampaignKeyword
             * @returns services.MutateKeywordPlanCampaignKeywordsResponse
             */
            create: async (keywordPlanCampaignKeywords, options) => {
                const ops = this.buildOperations("create", keywordPlanCampaignKeywords);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "KeywordPlanCampaignKeywordService.mutateKeywordPlanCampaignKeywords",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateKeywordPlanCampaignKeywords(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.IKeywordPlanCampaignKeyword
             * @returns services.MutateKeywordPlanCampaignKeywordsResponse
             */
            update: async (keywordPlanCampaignKeywords, options) => {
                const ops = this.buildOperations("update", keywordPlanCampaignKeywords, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.KeywordPlanCampaignKeyword);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "KeywordPlanCampaignKeywordService.mutateKeywordPlanCampaignKeywords",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateKeywordPlanCampaignKeywords(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateKeywordPlanCampaignKeywordsResponse
             */
            remove: async (keywordPlanCampaignKeywords, options) => {
                const ops = this.buildOperations("remove", keywordPlanCampaignKeywords);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "KeywordPlanCampaignKeywordService.mutateKeywordPlanCampaignKeywords",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateKeywordPlanCampaignKeywords(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/KeywordPlanCampaignService
     */
    get keywordPlanCampaigns() {
        const service = this.loadService("KeywordPlanCampaignServiceClient");
        return {
            /**
             * @description create resources of type resources.IKeywordPlanCampaign
             * @returns services.MutateKeywordPlanCampaignsResponse
             */
            create: async (keywordPlanCampaigns, options) => {
                const ops = this.buildOperations("create", keywordPlanCampaigns);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "KeywordPlanCampaignService.mutateKeywordPlanCampaigns",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateKeywordPlanCampaigns(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.IKeywordPlanCampaign
             * @returns services.MutateKeywordPlanCampaignsResponse
             */
            update: async (keywordPlanCampaigns, options) => {
                const ops = this.buildOperations("update", keywordPlanCampaigns, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.KeywordPlanCampaign);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "KeywordPlanCampaignService.mutateKeywordPlanCampaigns",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateKeywordPlanCampaigns(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateKeywordPlanCampaignsResponse
             */
            remove: async (keywordPlanCampaigns, options) => {
                const ops = this.buildOperations("remove", keywordPlanCampaigns);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "KeywordPlanCampaignService.mutateKeywordPlanCampaigns",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateKeywordPlanCampaigns(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/KeywordPlanService
     */
    get keywordPlans() {
        const service = this.loadService("KeywordPlanServiceClient");
        return {
            /**
             * @description create resources of type resources.IKeywordPlan
             * @returns services.MutateKeywordPlansResponse
             */
            create: async (keywordPlans, options) => {
                const ops = this.buildOperations("create", keywordPlans);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "KeywordPlanService.mutateKeywordPlans",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateKeywordPlans(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.IKeywordPlan
             * @returns services.MutateKeywordPlansResponse
             */
            update: async (keywordPlans, options) => {
                const ops = this.buildOperations("update", keywordPlans, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.KeywordPlan);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "KeywordPlanService.mutateKeywordPlans",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateKeywordPlans(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateKeywordPlansResponse
             */
            remove: async (keywordPlans, options) => {
                const ops = this.buildOperations("remove", keywordPlans);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "KeywordPlanService.mutateKeywordPlans",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateKeywordPlans(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/LabelService
     */
    get labels() {
        const service = this.loadService("LabelServiceClient");
        return {
            /**
             * @description create resources of type resources.ILabel
             * @returns services.MutateLabelsResponse
             */
            create: async (labels, options) => {
                const ops = this.buildOperations("create", labels);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "LabelService.mutateLabels",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateLabels(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.ILabel
             * @returns services.MutateLabelsResponse
             */
            update: async (labels, options) => {
                const ops = this.buildOperations("update", labels, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.Label);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "LabelService.mutateLabels",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateLabels(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateLabelsResponse
             */
            remove: async (labels, options) => {
                const ops = this.buildOperations("remove", labels);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "LabelService.mutateLabels",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateLabels(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/MediaFileService
     */
    get mediaFiles() {
        const service = this.loadService("MediaFileServiceClient");
        return {
            /**
             * @description create resources of type resources.IMediaFile
             * @returns services.MutateMediaFilesResponse
             */
            create: async (mediaFiles, options) => {
                const ops = this.buildOperations("create", mediaFiles);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "MediaFileService.mutateMediaFiles",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateMediaFiles(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/RemarketingActionService
     */
    get remarketingActions() {
        const service = this.loadService("RemarketingActionServiceClient");
        return {
            /**
             * @description create resources of type resources.IRemarketingAction
             * @returns services.MutateRemarketingActionsResponse
             */
            create: async (remarketingActions, options) => {
                const ops = this.buildOperations("create", remarketingActions);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "RemarketingActionService.mutateRemarketingActions",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateRemarketingActions(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.IRemarketingAction
             * @returns services.MutateRemarketingActionsResponse
             */
            update: async (remarketingActions, options) => {
                const ops = this.buildOperations("update", remarketingActions, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.RemarketingAction);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "RemarketingActionService.mutateRemarketingActions",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateRemarketingActions(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/SharedCriterionService
     */
    get sharedCriteria() {
        const service = this.loadService("SharedCriterionServiceClient");
        return {
            /**
             * @description create resources of type resources.ISharedCriterion
             * @returns services.MutateSharedCriteriaResponse
             */
            create: async (sharedCriteria, options) => {
                const ops = this.buildOperations("create", sharedCriteria);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "SharedCriterionService.mutateSharedCriteria",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateSharedCriteria(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateSharedCriteriaResponse
             */
            remove: async (sharedCriteria, options) => {
                const ops = this.buildOperations("remove", sharedCriteria);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "SharedCriterionService.mutateSharedCriteria",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateSharedCriteria(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/SharedSetService
     */
    get sharedSets() {
        const service = this.loadService("SharedSetServiceClient");
        return {
            /**
             * @description create resources of type resources.ISharedSet
             * @returns services.MutateSharedSetsResponse
             */
            create: async (sharedSets, options) => {
                const ops = this.buildOperations("create", sharedSets);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "SharedSetService.mutateSharedSets",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateSharedSets(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.ISharedSet
             * @returns services.MutateSharedSetsResponse
             */
            update: async (sharedSets, options) => {
                const ops = this.buildOperations("update", sharedSets, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.SharedSet);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "SharedSetService.mutateSharedSets",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateSharedSets(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateSharedSetsResponse
             */
            remove: async (sharedSets, options) => {
                const ops = this.buildOperations("remove", sharedSets);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "SharedSetService.mutateSharedSets",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateSharedSets(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/SmartCampaignSettingService
     */
    get smartCampaignSettings() {
        const service = this.loadService("SmartCampaignSettingServiceClient");
        return {
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v14/SmartCampaignSettingService#getsmartcampaignstatus
             */
            getSmartCampaignStatus: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "SmartCampaignSettingService.GetSmartCampaignStatus",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.getSmartCampaignStatus(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.ISmartCampaignSetting
             * @returns services.MutateSmartCampaignSettingsResponse
             */
            update: async (smartCampaignSettings, options) => {
                const ops = this.buildOperations("update", smartCampaignSettings, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.SmartCampaignSetting);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "SmartCampaignSettingService.mutateSmartCampaignSettings",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateSmartCampaignSettings(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/UserListService
     */
    get userLists() {
        const service = this.loadService("UserListServiceClient");
        return {
            /**
             * @description create resources of type resources.IUserList
             * @returns services.MutateUserListsResponse
             */
            create: async (userLists, options) => {
                const ops = this.buildOperations("create", userLists);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "UserListService.mutateUserLists",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateUserLists(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.IUserList
             * @returns services.MutateUserListsResponse
             */
            update: async (userLists, options) => {
                const ops = this.buildOperations("update", userLists, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.UserList);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "UserListService.mutateUserLists",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateUserLists(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateUserListsResponse
             */
            remove: async (userLists, options) => {
                const ops = this.buildOperations("remove", userLists);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "UserListService.mutateUserLists",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateUserLists(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/BillingSetupService
     */
    get billingSetups() {
        const service = this.loadService("BillingSetupServiceClient");
        return {
            /**
             * @description create resources of type resources.IBillingSetup
             * @returns services.MutateBillingSetupResponse
             */
            create: async (billingSetups, options) => {
                const ops = this.buildOperations("create", billingSetups);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "BillingSetupService.mutateBillingSetup",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateBillingSetup(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateBillingSetupResponse
             */
            remove: async (billingSetups, options) => {
                const ops = this.buildOperations("remove", billingSetups);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "BillingSetupService.mutateBillingSetup",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateBillingSetup(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/ConversionAdjustmentUploadService
     */
    get conversionAdjustmentUploads() {
        const service = this.loadService("ConversionAdjustmentUploadServiceClient");
        return {
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v14/ConversionAdjustmentUploadService#uploadconversionadjustments
             */
            uploadConversionAdjustments: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "ConversionAdjustmentUploadService.UploadConversionAdjustments",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.uploadConversionAdjustments(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/ConversionUploadService
     */
    get conversionUploads() {
        const service = this.loadService("ConversionUploadServiceClient");
        return {
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v14/ConversionUploadService#uploadclickconversions
             */
            uploadClickConversions: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "ConversionUploadService.UploadClickConversions",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.uploadClickConversions(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v14/ConversionUploadService#uploadcallconversions
             */
            uploadCallConversions: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "ConversionUploadService.UploadCallConversions",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.uploadCallConversions(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/CustomAudienceService
     */
    get customAudiences() {
        const service = this.loadService("CustomAudienceServiceClient");
        return {
            /**
             * @description create resources of type resources.ICustomAudience
             * @returns services.MutateCustomAudiencesResponse
             */
            create: async (customAudiences, options) => {
                const ops = this.buildOperations("create", customAudiences);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CustomAudienceService.mutateCustomAudiences",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCustomAudiences(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.ICustomAudience
             * @returns services.MutateCustomAudiencesResponse
             */
            update: async (customAudiences, options) => {
                const ops = this.buildOperations("update", customAudiences, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.CustomAudience);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CustomAudienceService.mutateCustomAudiences",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCustomAudiences(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateCustomAudiencesResponse
             */
            remove: async (customAudiences, options) => {
                const ops = this.buildOperations("remove", customAudiences);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CustomAudienceService.mutateCustomAudiences",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCustomAudiences(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/CustomInterestService
     */
    get customInterests() {
        const service = this.loadService("CustomInterestServiceClient");
        return {
            /**
             * @description create resources of type resources.ICustomInterest
             * @returns services.MutateCustomInterestsResponse
             */
            create: async (customInterests, options) => {
                const ops = this.buildOperations("create", customInterests);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CustomInterestService.mutateCustomInterests",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCustomInterests(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.ICustomInterest
             * @returns services.MutateCustomInterestsResponse
             */
            update: async (customInterests, options) => {
                const ops = this.buildOperations("update", customInterests, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.CustomInterest);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CustomInterestService.mutateCustomInterests",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCustomInterests(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/CustomerAssetSetService
     */
    get customerAssetSets() {
        const service = this.loadService("CustomerAssetSetServiceClient");
        return {
            /**
             * @description create resources of type resources.ICustomerAssetSet
             * @returns services.MutateCustomerAssetSetsResponse
             */
            create: async (customerAssetSets, options) => {
                const ops = this.buildOperations("create", customerAssetSets);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CustomerAssetSetService.mutateCustomerAssetSets",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCustomerAssetSets(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateCustomerAssetSetsResponse
             */
            remove: async (customerAssetSets, options) => {
                const ops = this.buildOperations("remove", customerAssetSets);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CustomerAssetSetService.mutateCustomerAssetSets",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCustomerAssetSets(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/CustomerClientLinkService
     */
    get customerClientLinks() {
        const service = this.loadService("CustomerClientLinkServiceClient");
        return {
            /**
             * @description create resources of type resources.ICustomerClientLink
             * @returns services.MutateCustomerClientLinkResponse
             */
            create: async (customerClientLinks, options) => {
                const ops = this.buildOperations("create", customerClientLinks);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CustomerClientLinkService.mutateCustomerClientLink",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCustomerClientLink(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.ICustomerClientLink
             * @returns services.MutateCustomerClientLinkResponse
             */
            update: async (customerClientLinks, options) => {
                const ops = this.buildOperations("update", customerClientLinks, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.CustomerClientLink);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CustomerClientLinkService.mutateCustomerClientLink",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCustomerClientLink(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/CustomerManagerLinkService
     */
    get customerManagerLinks() {
        const service = this.loadService("CustomerManagerLinkServiceClient");
        return {
            /**
             * @description update resources of type resources.ICustomerManagerLink
             * @returns services.MutateCustomerManagerLinkResponse
             */
            update: async (customerManagerLinks, options) => {
                const ops = this.buildOperations("update", customerManagerLinks, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.CustomerManagerLink);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CustomerManagerLinkService.mutateCustomerManagerLink",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCustomerManagerLink(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v14/CustomerManagerLinkService#movemanagerlink
             */
            moveManagerLink: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CustomerManagerLinkService.MoveManagerLink",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.moveManagerLink(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/CustomerSkAdNetworkConversionValueSchemaService
     */
    get customerSkAdNetworkConversionValueSchemas() {
        const service = this.loadService("CustomerSkAdNetworkConversionValueSchemaServiceClient");
        return {
            /**
             * @description update resources of type resources.ICustomerSkAdNetworkConversionValueSchema
             * @returns services.MutateCustomerSkAdNetworkConversionValueSchemaResponse
             */
            update: async (customerSkAdNetworkConversionValueSchemas, options) => {
                const ops = this.buildOperations("update", customerSkAdNetworkConversionValueSchemas, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.CustomerSkAdNetworkConversionValueSchema);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CustomerSkAdNetworkConversionValueSchemaService.mutateCustomerSkAdNetworkConversionValueSchema",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCustomerSkAdNetworkConversionValueSchema(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/CustomerUserAccessInvitationService
     */
    get customerUserAccessInvitations() {
        const service = this.loadService("CustomerUserAccessInvitationServiceClient");
        return {
            /**
             * @description create resources of type resources.ICustomerUserAccessInvitation
             * @returns services.MutateCustomerUserAccessInvitationResponse
             */
            create: async (customerUserAccessInvitations, options) => {
                const ops = this.buildOperations("create", customerUserAccessInvitations);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CustomerUserAccessInvitationService.mutateCustomerUserAccessInvitation",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCustomerUserAccessInvitation(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateCustomerUserAccessInvitationResponse
             */
            remove: async (customerUserAccessInvitations, options) => {
                const ops = this.buildOperations("remove", customerUserAccessInvitations);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CustomerUserAccessInvitationService.mutateCustomerUserAccessInvitation",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCustomerUserAccessInvitation(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/CustomerUserAccessService
     */
    get customerUserAccesses() {
        const service = this.loadService("CustomerUserAccessServiceClient");
        return {
            /**
             * @description update resources of type resources.ICustomerUserAccess
             * @returns services.MutateCustomerUserAccessResponse
             */
            update: async (customerUserAccesses, options) => {
                const ops = this.buildOperations("update", customerUserAccesses, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.CustomerUserAccess);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CustomerUserAccessService.mutateCustomerUserAccess",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCustomerUserAccess(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateCustomerUserAccessResponse
             */
            remove: async (customerUserAccesses, options) => {
                const ops = this.buildOperations("remove", customerUserAccesses);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CustomerUserAccessService.mutateCustomerUserAccess",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCustomerUserAccess(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/GeoTargetConstantService
     */
    get geoTargetConstants() {
        const service = this.loadService("GeoTargetConstantServiceClient");
        return {
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v14/GeoTargetConstantService#suggestgeotargetconstants
             */
            suggestGeoTargetConstants: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "GeoTargetConstantService.SuggestGeoTargetConstants",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.suggestGeoTargetConstants(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/InvoiceService
     */
    get invoices() {
        const service = this.loadService("InvoiceServiceClient");
        return {
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v14/InvoiceService#listinvoices
             */
            listInvoices: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "InvoiceService.ListInvoices",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.listInvoices(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/KeywordPlanIdeaService
     */
    get keywordPlanIdeas() {
        const service = this.loadService("KeywordPlanIdeaServiceClient");
        return {
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v14/KeywordPlanIdeaService#generatekeywordideas
             */
            generateKeywordIdeas: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "KeywordPlanIdeaService.GenerateKeywordIdeas",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.generateKeywordIdeas(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v14/KeywordPlanIdeaService#generatekeywordhistoricalmetrics
             */
            generateKeywordHistoricalMetrics: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "KeywordPlanIdeaService.GenerateKeywordHistoricalMetrics",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.generateKeywordHistoricalMetrics(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v14/KeywordPlanIdeaService#generateadgroupthemes
             */
            generateAdGroupThemes: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "KeywordPlanIdeaService.GenerateAdGroupThemes",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.generateAdGroupThemes(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v14/KeywordPlanIdeaService#generatekeywordforecastmetrics
             */
            generateKeywordForecastMetrics: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "KeywordPlanIdeaService.GenerateKeywordForecastMetrics",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.generateKeywordForecastMetrics(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/KeywordThemeConstantService
     */
    get keywordThemeConstants() {
        const service = this.loadService("KeywordThemeConstantServiceClient");
        return {
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v14/KeywordThemeConstantService#suggestkeywordthemeconstants
             */
            suggestKeywordThemeConstants: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "KeywordThemeConstantService.SuggestKeywordThemeConstants",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.suggestKeywordThemeConstants(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/MerchantCenterLinkService
     */
    get merchantCenterLinks() {
        const service = this.loadService("MerchantCenterLinkServiceClient");
        return {
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v14/MerchantCenterLinkService#listmerchantcenterlinks
             */
            listMerchantCenterLinks: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "MerchantCenterLinkService.ListMerchantCenterLinks",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.listMerchantCenterLinks(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v14/MerchantCenterLinkService#getmerchantcenterlink
             */
            getMerchantCenterLink: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "MerchantCenterLinkService.GetMerchantCenterLink",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.getMerchantCenterLink(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.IMerchantCenterLink
             * @returns services.MutateMerchantCenterLinkResponse
             */
            update: async (merchantCenterLinks, options) => {
                const ops = this.buildOperations("update", merchantCenterLinks, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.MerchantCenterLink);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "MerchantCenterLinkService.mutateMerchantCenterLink",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateMerchantCenterLink(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateMerchantCenterLinkResponse
             */
            remove: async (merchantCenterLinks, options) => {
                const ops = this.buildOperations("remove", merchantCenterLinks);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "MerchantCenterLinkService.mutateMerchantCenterLink",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateMerchantCenterLink(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/OfflineUserDataJobService
     */
    get offlineUserDataJobs() {
        const service = this.loadService("OfflineUserDataJobServiceClient");
        return {
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v14/OfflineUserDataJobService#createofflineuserdatajob
             */
            createOfflineUserDataJob: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "OfflineUserDataJobService.CreateOfflineUserDataJob",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.createOfflineUserDataJob(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v14/OfflineUserDataJobService#addofflineuserdatajoboperations
             */
            addOfflineUserDataJobOperations: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "OfflineUserDataJobService.AddOfflineUserDataJobOperations",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.addOfflineUserDataJobOperations(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v14/OfflineUserDataJobService#runofflineuserdatajob
             */
            runOfflineUserDataJob: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "OfflineUserDataJobService.RunOfflineUserDataJob",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.runOfflineUserDataJob(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/PaymentsAccountService
     */
    get paymentsAccounts() {
        const service = this.loadService("PaymentsAccountServiceClient");
        return {
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v14/PaymentsAccountService#listpaymentsaccounts
             */
            listPaymentsAccounts: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "PaymentsAccountService.ListPaymentsAccounts",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.listPaymentsAccounts(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/ProductLinkService
     */
    get productLinks() {
        const service = this.loadService("ProductLinkServiceClient");
        return {
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v14/ProductLinkService#createproductlink
             */
            createProductLink: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "ProductLinkService.CreateProductLink",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.createProductLink(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v14/ProductLinkService#removeproductlink
             */
            removeProductLink: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "ProductLinkService.RemoveProductLink",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.removeProductLink(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/ReachPlanService
     */
    get reachPlans() {
        const service = this.loadService("ReachPlanServiceClient");
        return {
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v14/ReachPlanService#listplannablelocations
             */
            listPlannableLocations: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "ReachPlanService.ListPlannableLocations",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.listPlannableLocations(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v14/ReachPlanService#listplannableproducts
             */
            listPlannableProducts: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "ReachPlanService.ListPlannableProducts",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.listPlannableProducts(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v14/ReachPlanService#generatereachforecast
             */
            generateReachForecast: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "ReachPlanService.GenerateReachForecast",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.generateReachForecast(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/RecommendationService
     */
    get recommendations() {
        const service = this.loadService("RecommendationServiceClient");
        return {
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v14/RecommendationService#applyrecommendation
             */
            applyRecommendation: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "RecommendationService.ApplyRecommendation",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.applyRecommendation(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v14/RecommendationService#dismissrecommendation
             */
            dismissRecommendation: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "RecommendationService.DismissRecommendation",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.dismissRecommendation(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/SmartCampaignSuggestService
     */
    get smartCampaignSuggests() {
        const service = this.loadService("SmartCampaignSuggestServiceClient");
        return {
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v14/SmartCampaignSuggestService#suggestsmartcampaignbudgetoptions
             */
            suggestSmartCampaignBudgetOptions: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "SmartCampaignSuggestService.SuggestSmartCampaignBudgetOptions",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.suggestSmartCampaignBudgetOptions(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v14/SmartCampaignSuggestService#suggestsmartcampaignad
             */
            suggestSmartCampaignAd: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "SmartCampaignSuggestService.SuggestSmartCampaignAd",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.suggestSmartCampaignAd(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v14/SmartCampaignSuggestService#suggestkeywordthemes
             */
            suggestKeywordThemes: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "SmartCampaignSuggestService.SuggestKeywordThemes",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.suggestKeywordThemes(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/ThirdPartyAppAnalyticsLinkService
     */
    get thirdPartyAppAnalyticsLinks() {
        const service = this.loadService("ThirdPartyAppAnalyticsLinkServiceClient");
        return {
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v14/ThirdPartyAppAnalyticsLinkService#regenerateshareablelinkid
             */
            regenerateShareableLinkId: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "ThirdPartyAppAnalyticsLinkService.RegenerateShareableLinkId",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.regenerateShareableLinkId(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/TravelAssetSuggestionService
     */
    get travelAssetSuggestions() {
        const service = this.loadService("TravelAssetSuggestionServiceClient");
        return {
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v14/TravelAssetSuggestionService#suggesttravelassets
             */
            suggestTravelAssets: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "TravelAssetSuggestionService.SuggestTravelAssets",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.suggestTravelAssets(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v14/UserDataService
     */
    get userData() {
        const service = this.loadService("UserDataServiceClient");
        return {
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v14/UserDataService#uploaduserdata
             */
            uploadUserData: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "UserDataService.UploadUserData",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.uploadUserData(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
}
exports.default = ServiceFactory;
